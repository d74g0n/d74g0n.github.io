<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>d74g0n Cannon</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none; /* Prevent text highlighting on double clicks */
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
            font-size: 1.1rem;
            line-height: 1.5;
        }
        #items-board { color: #00FF00; }
        #start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px 40px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
            pointer-events: none; /* Let clicks pass through to body/canvas */
        }
        h1 { margin: 0; color: #ffcc00; }
        p { font-size: 1.2rem; line-height: 1.6; }
        .hidden { display: none !important; }
        
        /* Stat Colors */
        .stat-items { color: #00FF00; font-weight: bold; }
        .stat-height { color: #00BFFF; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">Distance: 0m</div>
        <div id="speed-board">Speed: 0</div>
        <div id="height-board">Height: 0m</div>
        <div id="items-board">Items: 0</div> 
    </div>

    <div id="start-screen">
        <h1>d74g0n Cannon</h1>
        <p>Press <strong>SPACEBAR</strong> or <strong>CLICK / TAP</strong> to launch!</p>
        <p>Hit Orbs to gain lift.</p>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('start-screen');
    
    const scoreBoard = document.getElementById('score-board');
    const speedBoard = document.getElementById('speed-board');
    const heightBoard = document.getElementById('height-board');
    const itemsBoard = document.getElementById('items-board');

    let width, height;
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // Game Constants
    const GRAVITY = 0.15;
    const GROUND_FRICTION = 0.96;
    const AIR_RESISTANCE = 0.998; 
    const BASE_POWER = 25;
    const LIFT_POWER = 15; 
    const SPEED_BOOST = 2; 
    const COLUMN_WIDTH = 100; 
    
    // Game State
    let gameState = 'START'; 
    let cameraOffset = 0;
    let cameraY = 0; 
    
    // Stats
    let score = 0; // Distance
    let itemsCollected = 0;
    let maxAltitude = 0;

    let cannon = { x: 100, y: 0, angle: 45, angleDir: 1 };
    let ball = { x: 0, y: 0, vx: 0, vy: 0, radius: 10, rotation: 0 };
    let items = [];
    let nextItemX = 0;

    function resetGame() {
        gameState = 'AIMING';
        startScreen.classList.add('hidden');
        
        cannon.y = height - 50;
        cannon.angle = 45;
        
        ball.x = cannon.x;
        ball.y = cannon.y;
        ball.vx = 0;
        ball.vy = 0;
        ball.radius = 10;
        
        cameraOffset = 0;
        cameraY = 0;
        
        // Reset Stats
        score = 0;
        itemsCollected = 0;
        maxAltitude = 0;
        
        items = [];
        nextItemX = 400; 
        generateItems(2000); 
    }

    function generateItems(uptoX) {
        while (nextItemX < uptoX) {
            
            let screenTop = ball.y - (height * 0.5);
            let spawnMinY = screenTop; 
            let spawnMaxY = screenTop + (height / 3);

            if (spawnMaxY > height - 100) {
                spawnMaxY = height - 150;
                spawnMinY = height - 400;
            }

            let count = Math.floor(Math.random() * 4); 
            if (count === 0 && Math.random() > 0.2) count = 1; 

            let spawnedInThisColumn = [];

            for (let i = 0; i < count; i++) {
                let candidateY = spawnMinY + Math.random() * (spawnMaxY - spawnMinY);

                let touching = false;
                for (let existingY of spawnedInThisColumn) {
                    if (Math.abs(candidateY - existingY) < 40) {
                        touching = true;
                        break;
                    }
                }

                if (!touching) {
                    items.push({
                        x: nextItemX,
                        y: candidateY,
                        radius: 15 + (Math.random() * 5),
                        active: true
                    });
                    spawnedInThisColumn.push(candidateY);
                }
            }
            nextItemX += COLUMN_WIDTH + (ball.radius*3) + (Math.random() * 40);
        }
    }

    // --- INPUT HANDLING START ---
    
    function handleInput(e) {
        // If it's a keyboard event, only allow Spacebar
        if (e.type === 'keydown' && e.code !== 'Space') return;

        // Prevent default scrolling/highlighting behavior
        if(e.cancelable) e.preventDefault(); 

        // Logic
        if (gameState === 'START' || gameState === 'ENDED') {
            resetGame();
        } else if (gameState === 'AIMING') {
            fireCannon();
        }
    }

    // Add listeners for Keyboard, Mouse, and Touch
    window.addEventListener('keydown', handleInput);
    window.addEventListener('mousedown', handleInput);
    // 'passive: false' allows us to use preventDefault() to stop scrolling on mobile
    window.addEventListener('touchstart', handleInput, { passive: false });

    // --- INPUT HANDLING END ---

    function fireCannon() {
        gameState = 'FLYING';
        let rad = -cannon.angle * (Math.PI / 180);
        let barrelLen = 60; 
        ball.x = cannon.x + Math.cos(rad) * barrelLen;
        ball.y = cannon.y + Math.sin(rad) * barrelLen;
        ball.vx = Math.cos(rad) * BASE_POWER;
        ball.vy = Math.sin(rad) * BASE_POWER;
    }

    function update() {
        if (gameState === 'AIMING') {
            cannon.angle += cannon.angleDir * 1.5;
            if (cannon.angle > 80 || cannon.angle < 20) cannon.angleDir *= -1;
            ball.x = cannon.x;
            ball.y = cannon.y;
        }

        if (gameState === 'FLYING') {
            ball.vy += GRAVITY;
            ball.vx *= AIR_RESISTANCE; 
            ball.x += ball.vx;
            ball.y += ball.vy;
            ball.rotation += ball.vx * 0.05;

            // Ground Collision
            if (ball.y + ball.radius >= height - 20) {
                ball.y = height - 20 - ball.radius;
                ball.vy = -ball.vy * 0.5; 
                ball.vx *= GROUND_FRICTION; 

                if (Math.abs(ball.vx) < 0.1 && Math.abs(ball.vy) < 0.5) {
                    gameState = 'ENDED';
                    startScreen.classList.remove('hidden');
                    
                    startScreen.querySelector('h1').innerText = `Dist: ${Math.floor(score)}m`;
                    startScreen.querySelector('p').innerHTML = 
                        `Items: <span class="stat-items">${itemsCollected}</span><br>` +
                        `Max Height: <span class="stat-height">${maxAltitude}m</span><br><br>` +
                        `Press <strong>SPACE</strong> or <strong>TAP</strong> to try again`;
                }
            }

            // Item Collision
            for (let i = 0; i < items.length; i++) {
                let item = items[i];
                if (!item.active) continue;
                let dx = ball.x - item.x;
                let dy = ball.y - item.y;
                let distance = Math.sqrt(dx*dx + dy*dy);

                if (distance < ball.radius + item.radius) {
                    item.active = false; 
                    itemsCollected++;
                    ball.radius += 1;
                    ball.vy = -LIFT_POWER; 
                    ball.vx += SPEED_BOOST; 
                    if(ball.vx > 30) ball.vx = 30;
                }
            }

            // Camera
            if (ball.x > cameraOffset + width * 0.2) {
                cameraOffset = ball.x - width * 0.2;
            }
            cameraY = Math.min(0, ball.y - height * 0.5);

            generateItems(cameraOffset + width * 2);
            items = items.filter(item => item.x > cameraOffset - 100);
            score = Math.max(score, (ball.x - 100) / 10);
            
            // Track Max Altitude
            let currentHeight = Math.floor((height - 20 - ball.y) / 10);
            if (currentHeight < 0) currentHeight = 0;
            
            if (currentHeight > maxAltitude) {
                maxAltitude = currentHeight;
            }
        }

        // UI Updates
        scoreBoard.innerText = `Distance: ${Math.floor(score)}m`;
        speedBoard.innerText = `Speed: ${Math.abs(Math.floor(ball.vx * 10))}`;
        
        let currentHeight = Math.floor((height - 20 - ball.y) / 10);
        heightBoard.innerText = `Height: ${currentHeight > 0 ? currentHeight : 0}m`;
        
        itemsBoard.innerText = `Items: ${itemsCollected}`;
    }

    function draw() {
        // --- DYNAMIC BACKGROUND LOGIC ---
        
        // 1. Calculate Distance-based Color (Hue Shift)
        // Base Sky Blue is roughly HSL(197, 71%, 73%)
        const baseHue = 197; 
        const hueShiftRate = 60; // Degrees per 1000m
        const distanceHue = (baseHue + (score / 1000) * hueShiftRate) % 360;
        
        // 2. Calculate Height-based Darkness (Fade to Black)
        const altitude = Math.max(0, (height - 20 - ball.y) / 10);
        const spaceThreshold = 1000; // Meters where it becomes pitch black
        
        // Calculate how "dark" it should be (0 = normal sky, 1 = total black)
        const darknessRatio = Math.min(altitude / spaceThreshold, 1);
        
        // Standard Sky Lightness is ~73%
        const baseLightness = 73; 
        const currentLightness = baseLightness * (1 - darknessRatio);
        
        ctx.fillStyle = `hsl(${distanceHue}, 71%, ${currentLightness}%)`;
        ctx.fillRect(0, 0, width, height);
        // --------------------------------

        ctx.save();
        ctx.translate(-cameraOffset, -cameraY);

        // Items
        for (let item of items) {
            if (item.active) {
                ctx.beginPath();
                ctx.fillStyle = '#FFFF00';
                ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // Ground
        ctx.fillStyle = '#654321';
        ctx.fillRect(cameraOffset - 100, height - 20, width + 200, height); 
        ctx.fillStyle = '#228B22';
        ctx.fillRect(cameraOffset - 100, height - 25, width + 200, 5);

        // Cannon
        ctx.fillStyle = '#444';
        ctx.beginPath();
        ctx.arc(cannon.x, cannon.y, 20, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        ctx.translate(cannon.x, cannon.y);
        ctx.rotate(-cannon.angle * Math.PI / 180);
        ctx.fillStyle = '#333';
        ctx.fillRect(0, -10, 60, 20);
        ctx.restore();

        // Ball
        if (gameState !== 'START') {
            ctx.save();
            ctx.translate(ball.x, ball.y);
            ctx.rotate(ball.rotation);
            ctx.beginPath();
            ctx.fillStyle = '#FF4500';
            ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.fillRect(-5, -5, 10, 10);
            ctx.restore();
        }

        ctx.fillStyle = 'white';
        ctx.fillRect(cannon.x, height-25, 2, 25);

        ctx.restore();
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>